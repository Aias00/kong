#!/usr/bin/env bash
set -euo pipefail

LOCAL_PATH=$(dirname $(realpath $0))
source $LOCAL_PATH/common.sh

ACTION=merge

usage() {
  echo -e "PR issuer to \033[5msync\033[0m branches between kong repos."
  echo
  cat <<-EOF
$0 -f kong:next -t kong-ee:master
$0 -f kong:master -t kong-ee:next/2.1.0.x
$0 -f kong-ee:next/1.3.0.x -t kong-ee:next/1.5.0.x
$0 -f kong-ee:next/1.5.0.x -t kong-ee:next/2.1.0.x
$0 -f kong-ee:next/2.1.0.x -t kong-ee:master
EOF
}


function die {
  >&2 echo "$@"
  exit 1
}


parse_args() {
  if [[ "$1" == "dryrun" ]] || [[ "$1" == "dry-run" ]]; then
    ACTION=dryrun
    shift
  fi

  while getopts "f:t:h" option; do
    case $option in
      h)
        usage && die
        ;;
      f)
        from=$OPTARG
        f_repo=$(echo $from | cut -f1 -d: -s)
        f_repo=${f_repo:-kong-ee}

        f_branch=$(echo $from | cut -f2 -d:)
        ;;
      t)
        to=$OPTARG
        t_repo=$(echo $to | cut -f1 -d: -s)
        t_repo=${t_repo:-kong-ee}

        t_branch=$(echo $to | cut -f2 -d:)
        if [[ $t_repo != "kong-ee" ]] ; then
          die "to_repo must be kong-ee for now"
        fi
        ;;
    esac
  done

  echo ${from:?-f is mandatory}
  echo ${to:?-t is mandatory}
}


git-add-remote() {
  if ! git remote | grep "^${1}$" ; then
    git remote add "$1" "git@github.com:Kong/$1.git"
  fi
  on_exit "git-rem-remote $1"
}

git-rem-remote() {
  if git remote | grep "^${1}$" ; then
    git remote remove "$1"
  fi
}

to_branch_name() {
  echo $1 | tr ':' '-' | tr -d './'
}


main() {
  today=$(date +%F)
  parse_args "$@"
  git-add-remote $f_repo

  # we don't ever want to push to kongce by mistake
  [[ $f_repo == "kong" ]] && git remote set-url --push $f_repo DISABLED

  git-add-remote $t_repo

  git fetch $f_repo
  git fetch $t_repo

  # create a temporary branch to check how is the merge looking
  local new_branch_name
  new_branch_name=$(to_branch_name "merge-$from-into-$to-$today")
  git checkout -B $new_branch_name "$t_repo/$t_branch"

  # Determine if we should merge or show a diff
  if [[ "$ACTION" == "merge" ]]; then
    merge_output=$(git merge "$f_repo/$f_branch")
    merge_exit_status=$?

    if [[ "$merge_exit_status" -ne 0 ]] ; then
      # conflicts? bail out and you're on your own
      die "Conflicts detected. git merge --abort ??"

    elif echo "$merge_output" | grep "Already up to date."; then
      # nothing to merge
      git checkout -
      git branch -D "$new_branch_name"
      exit
    fi

    # was a clean merge (the commit is done locally)

    # we leave the merge to github to not have a doublemerge
    git push $t_repo $new_branch_name

    repo_text=""
    [[ $f_repo == "kong" ]] && repo_text="kong "

    title="Merge ${repo_text}$f_branch into $t_branch $today"
    body="BE CAREFUL RESOLVING CONFLICTS IN GH WEB INTERFACE: https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-on-github

--
$(curl https://quotebot.raimonster.workers.dev/ | jq -r .message)"

    browser "https://github.com/Kong/kong-ee/compare/${t_branch}...${new_branch_name}?expand=1&pull_request[title]=$title&pull_request[body]=$body"
  else
    set +eo pipefail
    {
      git merge --no-commit --no-ff "$f_repo/$f_branch";
      git status;
      git diff --color=always HEAD;
    } | less -r
    git merge --abort
    git checkout -
    git branch -D "$new_branch_name"
    set -eo pipefail
  fi
}

main "$@"

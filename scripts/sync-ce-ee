#!/usr/bin/env bash
set -euo pipefail

LOCAL_PATH=$(dirname $(realpath $0))

# Requirements for script execution
REQUIRED_COMMANDS=(cut date git grep hub)

source $LOCAL_PATH/common.sh

ACTION=merge

usage() {
  echo -e "PR issuer to \033[5msync\033[0m branches between kong repos."
  echo
  cat <<-EOF
$0 -f next/1.3.0.x -t next/1.5.0.x
$0 -f next/1.5.0.x -t next/2.1.x.x
$0 -f next/2.1.x.x -t next/2.2.x.x
$0 -f kong:master -t kong-ee:next/2.2.x.x
$0 -f kong:next -t kong-ee:master
$0 -f next/2.2.x.x -t master
EOF
}


function die {
  >&2 echo "$@"
  exit 1
}


parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -f|--from)
        from=$2
        f_repo=$(echo $from | cut -f1 -d: -s)
        f_repo=${f_repo:-kong-ee}

        f_branch=$(echo $from | cut -f2 -d:)
        shift
        ;;
      -t|--to)
        to=$2
        t_repo=$(echo $to | cut -f1 -d: -s)
        t_repo=${t_repo:-kong-ee}

        t_branch=$(echo $to | cut -f2 -d:)
        if [[ $t_repo != "kong-ee" ]] ; then
          die "to_repo must be kong-ee for now"
        fi
        shift
        ;;
      -pr|--pull-request)
        if [ "$#" -ge 2 ]; then
          local title="$2"
          local t_branch="$3"
        else
          die "PR title and to branch are required arguments"
        fi
        shift
        shift
        create_pr "$title" "$t_branch" 1
        exit 0
        ;;
      --check-requirements)
        check_requirements 1 0
        exit 0
        ;;
      --dryrun|--dry-run)
        ACTION=dryrun
        ;;
      -v|--verbose)
        set -x
        ;;
      -h|--help)
        usage
        exit 0
        ;;
    esac
    shift
  done

  echo ${from:?-f is mandatory}
  echo ${to:?-t is mandatory}
}


git-add-remote() {
  if ! git remote | grep "^${1}$" ; then
    git remote add "$1" "git@github.com:Kong/$1.git"
  fi
  on_exit "git-rem-remote $1"
}

git-rem-remote() {
  if git remote | grep "^${1}$" ; then
    git remote remove "$1"
  fi
}

to_branch_name() {
  echo $1 | tr ':' '-' | tr -d './'
}


create_pr() {
  local title="$1"
  local t_branch="$2"
  set +u
  local open_browser=""
  if [ ! -z $3 ] && [ $3 -eq 1 ]; then
    open_browser="--browse"
  fi
  set -u

  local body="--
$(curl https://quotebot.raimonster.workers.dev/ | jq -r .message)"

  hub pull-request --message "$title" \
                   --message "$body" \
                   --base "$t_branch" \
                   --reviewer "Kong/team-fast-track" \
                   $open_browser
}


main() {
  today=$(date +%F)
  parse_args "$@"
  git-add-remote $f_repo

  # we don't ever want to push to kongce by mistake
  [[ $f_repo == "kong" ]] && git remote set-url --push $f_repo DISABLED

  git-add-remote $t_repo

  git fetch $f_repo
  git fetch $t_repo

  # create a temporary branch to check how is the merge looking
  local new_branch_name
  new_branch_name=$(to_branch_name "merge-$from-into-$to-$today")
  git checkout -B $new_branch_name "$t_repo/$t_branch"

  # Generate the title for the PR
  local repo_text=""
  [[ $f_repo == "kong" ]] && repo_text="kong "
  local title="Merge ${repo_text}$f_branch into $t_branch $today"

  # Determine if we should merge or show a diff
  if [[ "$ACTION" == "merge" ]]; then
    set +eo pipefail
    merge_output=$(git merge "$f_repo/$f_branch")
    merge_exit_status=$?
    set -eo pipefail

    if [[ "$merge_exit_status" -ne 0 ]] ; then
      # conflicts? bail out and you're on your own
      die "Conflicts detected; address conflicts and create PR:

  git add .
  git commit
  git push origin $new_branch_name
  $0 -pr \"$title\" \"$t_branch\"

  OR (if -pr|--pull-request are not available)

  hub pull-request --message \"$title\" \\
                   --message \"Manually addressed merge conflicts\" \\
                   --base $t_branch \\
                   --reviewer \"Kong/team-fast-track\" \\
                   --browse
"
    elif echo "$merge_output" | grep "Already up to date."; then
      # nothing to merge
      git checkout -
      git branch -D "$new_branch_name"
      exit
    fi

    # was a clean merge (the commit is done locally)

    # we leave the merge to github to not have a doublemerge
    git push $t_repo $new_branch_name
    create_pr "$title" "$t_branch"
  else
    set +eo pipefail
    {
      git merge --no-commit --no-ff "$f_repo/$f_branch";
      git status;
      git diff --color=always HEAD;
    } | less -r
    git merge --abort
    git checkout -
    git branch -D "$new_branch_name"
    set -eo pipefail
  fi
}

check_requirements
main "$@"
